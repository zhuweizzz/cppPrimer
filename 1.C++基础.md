 ## C++ 类 基础

>类的基本思想是**数据抽象(data abstraction)**和**封装**。数据抽象是一种依赖于**接口**(interface)和**实现**(implementation)分离的编程(以及设计)技术。类的接口包括用户所能执行的操作；类的实现则包括类的数据成员、负责接口实现的函数体以及定义类所需的各种私有函数。封装实现了类的接口和实现的分离。封装后的类隐藏了其实现细节，类的用户只能使用接口而无法访问实现部分

* 类的成员函数  
    定义和声明成员函数的方式和普通函数差不多。成员函数的声明必须在类内部，定义则既可以在类内部也可以在类外部。作为接口组成部分的非成员函数，其定义和声明都在类外部。
    ```cpp
    //类的成员函数
    struct Sales_date{
        std::string isbn(){return bookNo;}
        Sales_data& combine(const Sales_data&);
        double avg_price() const;

        std::string bookNo;
        unsigned units_sold = 0;
        double revenue = 0.0;
    }
    //类的非成员接口函数
    Sales_data add(const Sales_data&, const Sales_data& );
    std::ostream &print(std::ostream& , const Sales_data& );
    std::istream &read(std:: istream&, Sales_data& );

    ```

* `this`  
    >成员函数通过一个名为`this`的额外的隐式参数来访问调用它的那个对象。当调用成员函数时，用请求该函数的对象的地址初始化`this`。在成员函数内部，可以直接使用调用该函数的对象的成员，而无需通过成员访问运算符来进行访问，任何对类成员的访问都被看做是`this`的隐式引用。**this是一个常量指针**

* const成员函数     
    默认情况下，`this`的类型是指向类类型非常量版本的常量指针。所以无法在常量对象上调用普通的成员函数。当成员函数不会改变对象成员的值时，将`this`设置为指向常量的指针有助于提高函数的灵活性。  
    由于`this`参数是隐式的，C++中运行将const关键字放在函数的参数列表之后。
    ```cpp
     double avg_price() const;
    ```
    像这样使用`const`的成员函数被称作**常量成员函数**
    >Tips: 常量对象，以及常量对象的引用或指针都只能调用对象的常量成员函数

* 类作用域和成员函数
    >编译器分两步处理类：首先编译成员声明，然后才轮到成员函数体，因此，成员函数体可以随意使用类中其它成员而无需在意成员出现的顺序。


* 返回`this`对象的函数
    ```cpp
    Sales_data& Sales_data::combine(const Sales_data &rhs)
    {
        units_sold += rhs.units_sold;
        revenue += rhs.revenue;
        return *this; //返回调用该函数的对象的引用
    }
    ```
### 定义与类相关的非成员函数
>类的作者常常需要定义一些辅助函数，尽管这些函数的定义的操作从概念上讲属于类的接口部分，但其并不属于类。如果函数在概念上属于类，但是不定义在类中，则它一般应与类声明在同一个头文件内。

### 构造函数
>类定义了其对象被初始化的方式，类通过一个或几个特殊的成员函数来控制其对象的初始化过程，这些函数叫做**构造函数**

>构造函数的任务是初始化类对象的数据成员，无论何时只要类的对象被创建，就会执行构造函数
>* 构造函数的名字和类名相同
>* 构造函数无返回类型
>* 构造函数有一个参数列表（可能为空）和一个函数体（可能为空）
>* 类可以包含多个构造函数
>* 构造函数不能被声明为const

* 默认构造函数
    >对于没有提供初始值的对象，其执行力默认初始化。类通过一个特殊的构造函数来控制默认初始化的过程，这个构造函数被称为**默认构造函数**

    由编译器创建的构造函数又被称为**合成的默认构造函数**，对于大多数类，其初始化类的数据成员的规则是：
    >* 如果存在类内初始值，用它来初始化
    >*否则，默认初始化该成员

    **只有当类没有声明任何构造函数时，编译器才会自动地生成默认构造函数**

    `=default`在C++11新标准中，如果我们需要默认行为，可通过在参数列表后面写上`=default`来要求编译器合成默认构造函数。


* 构造函数初始值列表
    使用构造函数初始化列表:
    ```cpp
    Sales_data(const std:: string&s):bookNo(s){}
    Sales_data(const std:: string&s ,unsigned n,double p):
                bookNo(s),units_sold(n),revenue(p*n){}
    ```
    当某个数据成员被构造函数初始值列表忽略时，它将以与合成默认构造函数相同的方式隐式初始化。

* 拷贝、赋值、析构
    >除了要控制类的对象如何初始化之外，类还需要控制拷贝、赋值和销毁对象时发生的行为。如果不主动定义这些操作，则编译器将替我们合成它们。

    >某些类不能依赖于合成的版本，如管理动态内存的类。

* 访问控制与封装
    >在C++中使用**访问说明符**(access specifiers)加强类的封装性，使类的用户无法访问对象的内部而控制具体实现细节

    定义在`public`说明符之后的成员在整个程序内可被访问，`public`成员定义类的接口  
    定义在`private`说明符之后的成员可以被类的成员函数访问，但不能被使用类的代码访问，`private`部分封装了类的实现细节

    `class`和`struct`关键字：  
    两个都可以定义一个类，唯一的区别是，两者的默认访问权限不一样。  
    类可以在第一个访问说明符之前定义成员，这些成员的访问权限依赖于类定义的方式。使用`struct`关键字，则这类成员是`public`，相反，使用`class`这类成员则是`private`。
    >class 和 struct 定义的唯一区别就是默认访问权限。

 * 友元  
    有时我们需要定义一些并非类的成员函数的接口函数，而这部分函数无法访问到类的非公有部分。
    >类可以允许其它类或者函数访问它的非共有成员，方法是令其他类或者函数称为它的友元（friend）。如果类想把一个函数作为友元，只需要增加一条`friend`关键字开始的函数声明语句即可。友元只能出现在类内部，但位置不限，友元不是类的成员也不受它所在访问控制级别的约束。

    >一般来讲，最好在类的开始或者结束处集中声明友元

* 友元的声明
    >友元声明仅仅指定了访问权限，而非通常意义上的函数声明，所以为了使友元对类的用户可见，必须在友元声明之外，再专门对函数声明一次。通常将友元的声明与类本身放在同一个头文件中。

### 类的其它一些特性

* 类成员  
    - 在类内可以定义类型成员：  
    在类内，除了定义数据和函数成员之外，类还可以自定义某种类型在类中的别名。由类定义的类型名字和其它成员一样存在访问限制，可以是`public`或者`private`中的一种
    ```cpp
    class Screen{
        public:
            typedef std::string::size_type pos;
        private:
            pos cursor = 0;
            pos height = 0 , wight = 0;
            std::string contents;
    }
    ```
    >用来定义类型的成员必须先定义后使用，这一点与普通成员有区别
     
* 令成员作为内联函数
    定义在类内部的成员函数是自动inline的。我们可以在类的内部把`inline`作为声明的一部分显示的声明成员函数，也能在类外部用`inline`关键字修饰定义。最好值在类外部定义的地方说明`inline`。

* 成员函数的重载
        成员函数的重载与非成员函数一样，只要成员函数之间在参数的数量和类型上有所区别。

* `mutable`关键字 可变数据成员  
    我们有时希望能修改某个数据成员，即使是在`const`成员函数内。一个**可变数据成员**永远不会是`const`,一个`const`成员函数可以改变一个可变成员的值。
    ```cpp
        class Screen{
            public:
                void some_member() const;
            private:
                matable size_t access_ctr; //即使在一个const对象内也能修改
        }
        void Screen::some_member() const
        {
            ++access_ctr;
        }
    ```
* 返回`*this`的成员函数
    >区别返回调用对象的副本和返回调用对象的引用    

  从const成员函数返回*this
  >一个const成员如果以引用的形式返回 *this 指针，那么它的返回类型将是常量引用

* 基于const的重载  
    通过区分是否是const成员，可以对其进行重载。只能在一个常量对象上调用const成员函数，虽然可以在非常量对象上调用常量版本或非常量版本的函数，但此时非常量版本是一个更好的匹配。 

* 类的声明  
    类与函数一样

* 类之间的友元关系  
    类除了将非成员函数定义为友元，还可以把其他的类定义成友元，也可以将其他类的成员函数定义成友元。
    >如果一个类指定了友元类，则友元类的成员函数可以访问此类包括非公有成员在内的所有成员

    ```cpp
    class Screen{
        //Screen类将window_mgr类声明为自己的友元
        friend class Window_mgr;
    };
    ```
    >友元关系不存在传递关系，每个类负责控制自己的友元类或友元函数

* 令成员函数作为友元  
    除了将整个类声明为友元外，还可以将某个类的单个成员声明为友元，将一个成员声明为友元时，我们必须明确指出该成员属于哪个类。
    >想要令某个成员函数作为友元时，必须仔细组织程序的结，以满足声明和定义的依赖关系

* 友元声明和作用域
    >友元声明的作用是影响访问权限，其本身并非普通意义上的声明

    类和非成员函数的声明不一定必须在它的友元声明之前，当一个名字第一次出现在一个友元声明中时，隐式假定该名字在当前作用域中是可见的。

    ```cpp
    struct X{
        friend void f(){  /*友元可以定义在类的内部*/ }
        X(){ f(); }             //错误：此时f还没有声明 
        void g();
        void h();
    };
    void X::g(){ return f(); }  //错误：此时f还没有声明
    void f();                   //声明定义在X类中的函数
    void X::h(){ return f(); }  //正确：现在f的声明在作用域中了
    ```

* 类的作用域  
    每个类定义自己的作用域。在类的作用域之外，普通的数据和函数成员只能由对象、引用或者指针使用成员访问运算符来访问。对于类类型成员则使用作用域运算符访问。
 
 * 构造函数初始化列表
    >在定义变量时习惯于立即对其进行初始化，而非先定义再赋值，对于对象的数据成员而言，初始化和赋值也有区别。如果没有在构造函数的初始值列表中显式地初始化成员，则成员将在构造函数体之前执行默认初始化

    构造函数的初始值有时必不可少
    >有时可以忽略数据成员初始化和赋值之间的差异，但并不是所有时候都这样，如果成员是const或者是引用的话，则必须进行初始化。

    >初始化const或者引用类型的数据成员的唯一机会就是通过构造函数初始值。进行显式地初始化引用和const成员。初始化方法是在构造函数后使用初始化列表。 

* 隐式的类类型转换
    >c++中对于类类型，由只接受一个参数的构造函数来实现 该参数类型到类类型的转换，这是一种隐式转换，有时将这种构造函数称为**转换构造函数**

    ```cpp
        string null_book = "9-99-9999-9";
        item.combine(null_book); //此时sting类型隐式转换为Sales_date类类型
    ```

* `explicit`关键字  
    通过将构造函数声明为`explicit`来阻止隐式转换，同时关键字`explicit`只对一个实参的构造函数有效。需要多个实参的构造函数无法进行隐式转换，所以无需指定为`explicit`。只能在类内声明构造函数时使用`explicit`关键字。

    >当我们用explicit关键字声明构造函数时，它将只能以直接初始化形式使用(区别于拷贝初始化)。并且编译器将不会在自动转换过程中使用该构造函数。

### 类的静态成员
>在一些情况下我们需要类的一些成员直接与类相关，而不是与类的各个对象保持关联。
* 静态成员的声明  
    使用`static`关键字
    >类的静态成员存在于任何对象之外，对象中不包括任何于静态数据成员有关的数据。其静态成员只存在一个，且被所有对象共享。静态成员函数不与任何对象绑定在一起，并且不包含（this）指针。所有静态成员不能声明成const，并且也不能在static函数体内使用this指针(包括显示使用以及调用非静态成员时的隐式使用)

* 使用类的静态成员  
    可以用作用域运算符直接访问静态成员。
    >虽然静态成员不属于类的某个对象，但我们仍然可以使用类的对象、引用或者指针来访问静态成员
    成员函数可以不用作用域运算符直接访问

* 定义静态成员  
    既可以在类内部也可以在类外部定义静态成员函数。在类外定义静态成员函数时，不能重复`static`关键字。
    >和类的所有成员一样，当我们指向类外部的静态成员时，必须指明成员所属类名。`static`关键字则只出现在类内部声明语句中。
    静态数据成员不属于任何一个对象，所有其并不是在创建对象时被定义的，所以它们不是由类的构造函数初始化的。一般来说，我们不能在类的内部初始化静态成员，相反必须在类的外部定义和初始化每个静态成员，一个静态成员只能初始化一次。

* 静态成员的类内初始化
    通常情况下类的静态成员不应该在类内部初始化，但是可以在类内部为静态成员提供const整数类型的类内初始值，但要求静态成员必须是字面值常量类型constexpr。
    >即使一个常量静态数据成员在类内部被初始化了，通常情况下也应该在类的外部定义一下该成员

* 不完全类型   
    类的数据成员不能是类本身类型，但可以是指向类的指针。  
    静态成员可以是不完全类型，指针成员可以不完全类型
    ```cpp
    class Bar{
        public:
        //....
        private:
            static Bar mem1;  //正确：静态成员可以是不完全类型
            Bar *mem2;        //正确：指针成员可以是不完全类型
            Bar mem3;         //错误：数据成员必须是完全类型
    }
    ```



    






